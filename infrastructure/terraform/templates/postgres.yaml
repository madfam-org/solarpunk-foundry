#cloud-config
# Janua PostgreSQL Server Initialization
# ======================================

hostname: janua-postgres

package_update: true
package_upgrade: true

packages:
  - postgresql-14
  - postgresql-contrib-14
  - curl
  - htop
  - fail2ban
  - ufw

write_files:
  # PostgreSQL configuration
  - path: /etc/postgresql/14/main/conf.d/janua.conf
    content: |
      # Janua PostgreSQL Configuration
      # ==============================

      # Connection Settings
      listen_addresses = '10.1.2.10'
      port = 5432
      max_connections = 100

      # Memory Settings (optimized for 4GB RAM)
      shared_buffers = 1GB
      effective_cache_size = 3GB
      maintenance_work_mem = 256MB
      work_mem = 10MB

      # WAL Settings
      wal_buffers = 64MB
      min_wal_size = 1GB
      max_wal_size = 4GB
      checkpoint_completion_target = 0.9

      # Query Planner
      random_page_cost = 1.1
      effective_io_concurrency = 200

      # Logging
      logging_collector = on
      log_directory = 'log'
      log_filename = 'postgresql-%Y-%m-%d.log'
      log_rotation_age = 1d
      log_rotation_size = 100MB
      log_min_duration_statement = 1000
      log_checkpoints = on
      log_connections = on
      log_disconnections = on
      log_lock_waits = on

      # Autovacuum
      autovacuum = on
      autovacuum_max_workers = 3
      autovacuum_naptime = 60
      autovacuum_vacuum_threshold = 50
      autovacuum_analyze_threshold = 50

  # PostgreSQL HBA (Host-Based Authentication)
  - path: /etc/postgresql/14/main/pg_hba.conf
    content: |
      # PostgreSQL Client Authentication
      # =================================

      # Local connections
      local   all             postgres                                peer
      local   all             all                                     peer

      # IPv4 local connections
      host    all             all             127.0.0.1/32            scram-sha-256

      # Internal network (Janua services)
      host    janua           ${postgres_user}  10.1.0.0/16           scram-sha-256

      # Replication (future use)
      host    replication     all             10.1.0.0/16             scram-sha-256

  # Backup script
  - path: /opt/scripts/backup-postgres.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e

      BACKUP_DIR="/var/backups/postgresql"
      DATE=$(date +%Y%m%d_%H%M%S)
      BACKUP_FILE="$BACKUP_DIR/janua_$DATE.sql.gz"

      # Create backup directory
      mkdir -p $BACKUP_DIR

      # Perform backup
      sudo -u postgres pg_dump janua | gzip > $BACKUP_FILE

      # Keep only last 7 days of backups
      find $BACKUP_DIR -name "janua_*.sql.gz" -mtime +7 -delete

      echo "Backup completed: $BACKUP_FILE"

      # Optional: Upload to R2 (requires rclone configuration)
      # rclone copy $BACKUP_FILE r2:janua-backups/postgres/

  # Database initialization script
  - path: /opt/scripts/init-database.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e

      # Wait for PostgreSQL to be ready
      until pg_isready -h localhost -p 5432; do
        echo "Waiting for PostgreSQL..."
        sleep 2
      done

      # Create user and database
      sudo -u postgres psql <<EOF
      -- Create user if not exists
      DO \$\$
      BEGIN
        IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '${postgres_user}') THEN
          CREATE USER ${postgres_user} WITH PASSWORD '${postgres_password}';
        END IF;
      END
      \$\$;

      -- Create database if not exists
      SELECT 'CREATE DATABASE ${postgres_db} OWNER ${postgres_user}'
      WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '${postgres_db}')\gexec

      -- Grant privileges
      GRANT ALL PRIVILEGES ON DATABASE ${postgres_db} TO ${postgres_user};

      -- Connect to database and setup extensions
      \c ${postgres_db}

      -- Enable useful extensions
      CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
      CREATE EXTENSION IF NOT EXISTS "pgcrypto";

      -- Grant schema privileges
      GRANT ALL ON SCHEMA public TO ${postgres_user};
      EOF

      echo "Database initialized successfully"

  # Mount script for data volume
  - path: /opt/scripts/mount-data-volume.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e

      DATA_DEVICE="/dev/sdb"
      DATA_MOUNT="/mnt/postgres-data"

      # Wait for volume to be attached
      while [ ! -e $DATA_DEVICE ]; do
        echo "Waiting for data volume..."
        sleep 5
      done

      # Create mount point
      mkdir -p $DATA_MOUNT

      # Check if already formatted
      if ! blkid $DATA_DEVICE | grep -q ext4; then
        echo "Formatting data volume..."
        mkfs.ext4 $DATA_DEVICE
      fi

      # Mount volume
      mount $DATA_DEVICE $DATA_MOUNT

      # Add to fstab for persistence
      if ! grep -q $DATA_MOUNT /etc/fstab; then
        echo "$DATA_DEVICE $DATA_MOUNT ext4 defaults,noatime 0 2" >> /etc/fstab
      fi

      # Setup PostgreSQL data directory
      if [ ! -d "$DATA_MOUNT/postgresql" ]; then
        mkdir -p $DATA_MOUNT/postgresql
        chown postgres:postgres $DATA_MOUNT/postgresql
        chmod 700 $DATA_MOUNT/postgresql
      fi

      echo "Data volume mounted at $DATA_MOUNT"

  # Health check script
  - path: /opt/scripts/health-check.sh
    permissions: '0755'
    content: |
      #!/bin/bash

      echo "=== PostgreSQL Health Check ==="

      if pg_isready -h localhost -p 5432; then
        echo "âœ… PostgreSQL: accepting connections"
      else
        echo "âŒ PostgreSQL: not ready"
        exit 1
      fi

      # Check database exists
      if sudo -u postgres psql -lqt | cut -d \| -f 1 | grep -qw ${postgres_db}; then
        echo "âœ… Database '${postgres_db}': exists"
      else
        echo "âŒ Database '${postgres_db}': missing"
        exit 1
      fi

      # Check connections
      CONN_COUNT=$(sudo -u postgres psql -t -c "SELECT count(*) FROM pg_stat_activity WHERE datname = '${postgres_db}';" | tr -d ' ')
      echo "ðŸ“Š Active connections: $CONN_COUNT"

      # Check disk usage
      DATA_SIZE=$(sudo -u postgres psql -t -c "SELECT pg_size_pretty(pg_database_size('${postgres_db}'));" | tr -d ' ')
      echo "ðŸ’¾ Database size: $DATA_SIZE"

  # UFW rules
  - path: /opt/scripts/setup-firewall.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e

      ufw --force reset
      ufw default deny incoming
      ufw default allow outgoing

      # Allow SSH from private network only
      ufw allow from 10.1.0.0/16 to any port 22

      # Allow PostgreSQL from app subnet
      ufw allow from 10.1.1.0/24 to any port 5432

      ufw --force enable
      echo "Firewall configured"

  # Cron job for daily backups
  - path: /etc/cron.d/postgres-backup
    content: |
      # Daily backup at 3 AM
      0 3 * * * root /opt/scripts/backup-postgres.sh >> /var/log/postgres-backup.log 2>&1

runcmd:
  # Mount data volume first
  - /opt/scripts/mount-data-volume.sh || true

  # Stop PostgreSQL to configure
  - systemctl stop postgresql

  # Move data directory to mounted volume if available
  - |
    if [ -d "/mnt/postgres-data/postgresql" ]; then
      if [ ! -L "/var/lib/postgresql/14/main" ]; then
        rsync -av /var/lib/postgresql/14/main/ /mnt/postgres-data/postgresql/
        rm -rf /var/lib/postgresql/14/main
        ln -s /mnt/postgres-data/postgresql /var/lib/postgresql/14/main
        chown -h postgres:postgres /var/lib/postgresql/14/main
      fi
    fi

  # Start PostgreSQL
  - systemctl start postgresql
  - systemctl enable postgresql

  # Initialize database
  - /opt/scripts/init-database.sh

  # Setup firewall
  - /opt/scripts/setup-firewall.sh

  # Enable fail2ban
  - systemctl enable fail2ban
  - systemctl start fail2ban

  - echo "PostgreSQL server initialization complete" | tee /var/log/cloud-init-postgres.log

final_message: "PostgreSQL server ready after $UPTIME seconds"
